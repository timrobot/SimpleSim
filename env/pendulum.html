<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Robot Sim</title>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
          "three/examples/jsm/": "https://unpkg.com/three@0.161.0/examples/jsm/",
          "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
        }
      }
    </script>
    <script type="module" src="/static/js/lan.js"></script>


    <style type="text/css">
      * {
        margin: 0;
        padding: 0;
      }

      /* half-size render */
      #viewport {
        position: absolute;
        bottom: 0px;
        right: 0px;
        width: 320px;
        height: 180px;
        border: 1px solid black;
      }
    </style>


<script id="post-vert" type="x-shader/x-vertex">
  varying vec2 vUv;

  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
</script>
<script id="post-frag" type="x-shader/x-fragment">
  #include <packing>

  varying vec2 vUv;
  uniform sampler2D tDiffuse;
  uniform sampler2D tDepth;
  uniform float cameraNear;
  uniform float cameraFar;


  float readDepth( sampler2D depthSampler, vec2 coord ) {
    float fragCoordZ = texture2D( depthSampler, coord ).x;
    float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
    return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );
  }

  void main() {
    //vec3 diffuse = texture2D( tDiffuse, vUv ).rgb;
    float depth = readDepth( tDepth, vUv );
    float mpost250;
    float mm250 = modf(depth * 256.0f, mpost250);

    gl_FragColor.rgb = vec3( mm250, mpost250 / 256.0f, 0 );
    //gl_FragColor.a = 1.0;
  }
</script>

  </head>
  <body>
    <div id="container"></div>
    <!-- <canvas id="viewport"></canvas> -->
    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
      import WSConnection from '/static/js/lan.js';

      // Create a scene + physics
      const scene = new THREE.Scene();

      // Create a camera
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50);
      camera.position.set(0, 3, 5); // look from the "back"
      camera.lookAt(0, 0, 0);

      // Create a renderer
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.shadowMap.enabled = true;
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setClearColor(0x80c0e0);
      const container = document.getElementById('container');
      container.appendChild(renderer.domElement);

      // // Create a renderer for the viewport (todo)
      // const viewportRenderer = new THREE.WebGLRenderer({ antialias: true });
      // viewportRenderer.setSize(320, 180);
      // viewportRenderer.setPixelRatio(window.devicePixelRatio);
      // const viewport = document.getElementById('viewport');
      // viewport.appendChild(viewportRenderer.domElement);

      // Setup lights
      const dirLight = new THREE.DirectionalLight();
      dirLight.position.set(15, 50, -15);
      dirLight.castShadow = true;
      dirLight.shadow.camera.left = -100;
      dirLight.shadow.camera.right = 100;
      dirLight.shadow.camera.bottom = -100;
      dirLight.shadow.camera.top = 100;
      dirLight.shadow.camera.near = 0.1;
      dirLight.shadow.camera.far = 100;
      scene.add(dirLight);

      const dirLight2 = new THREE.DirectionalLight();
      dirLight2.position.set(-15, 50, 15);
      dirLight2.castShadow = true;
      dirLight2.shadow.camera.left = -100;
      dirLight2.shadow.camera.right = 100;
      dirLight2.shadow.camera.bottom = -100;
      dirLight2.shadow.camera.top = 100;
      dirLight2.shadow.camera.near = 0.1;
      dirLight2.shadow.camera.far = 100;
      scene.add(dirLight2);

      const amLight = new THREE.AmbientLight();
      amLight.intensity = 0.5;
      scene.add(amLight);

      // Create controller for viewing
      const controller = new OrbitControls(camera, renderer.domElement);

      // Create a ground plane in Three.js
      const groundGeometry = new THREE.BoxGeometry(50, 1, 50);
      const groundMaterial = new THREE.MeshLambertMaterial({color: 0xdacfa3});
      const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
      groundMesh.position.set(0, -0.5, 0);
      groundMesh.castShadow = true;
      groundMesh.receiveShadow = true;
      scene.add(groundMesh);

      const streamCamera = new THREE.PerspectiveCamera(75, 640 / 360, 0.1, 50);
      streamCamera.position.set(0, 2.5, 2);
      streamCamera.lookAt(0, 2.5, 0); // look backward

      const pendulumGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 16);
      const pendulumMaterial = new THREE.MeshLambertMaterial({color: 0xff0000});
      const pendulum = new THREE.Mesh(pendulumGeometry, pendulumMaterial);
      pendulum.position.set(0, 2, 0);
      
      pendulum.castShadow = true;
      pendulum.receiveShadow = true;
      scene.add(pendulum);

      // Create websocket connection, add bodies to track
      const connection = new WSConnection(9999, 640, 360, 0.1, 60, scene, streamCamera);
      connection.bodies['pendulum_joint'] = pendulum;

      window.addEventListener('resize', () => {
        const width = window.innerWidth;
        const height = window.innerHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
      });

      function render() {
        renderer.render(scene, camera);
      }
      renderer.setAnimationLoop(render);

    </script>
  </body>
</html>
